--- a/net/minecraft/entity/EntityLivingBase.java
+++ b/net/minecraft/entity/EntityLivingBase.java
@@ -1,5 +1,7 @@
 package net.minecraft.entity;
 
+import carpet.CarpetSettings;
+import carpet.logging.logHelpers.DamageReporter;
 import com.google.common.base.Objects;
 import com.google.common.collect.Maps;
 import java.util.Collection;
@@ -139,6 +141,8 @@
     protected int scoreValue;
     protected float lastDamage;
     protected boolean isJumping;
+    //CM public for ghast helper
+    public boolean getJumping() { return isJumping; }
     public float moveStrafing;
     public float moveVertical;
     public float moveForward;
@@ -169,6 +173,11 @@
     private float swimAnimation;
     private float lastSwimAnimation;
 
+    //CM
+    @Override
+    public String cm_name() { return "Other Living Entity"; }
+
+
     protected EntityLivingBase(EntityType<?> type, World p_i48577_2_)
     {
         super(type, p_i48577_2_);
@@ -917,12 +926,14 @@
         }
         else
         {
+            DamageReporter.register_damage(this, source, amount); //CM
             this.idleTime = 0;
             float f = amount;
 
             if ((source == DamageSource.ANVIL || source == DamageSource.FALLING_BLOCK) && !this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).isEmpty())
             {
                 this.getItemStackFromSlot(EntityEquipmentSlot.HEAD).damageItem((int)(amount * 4.0F + this.rand.nextFloat() * amount * 2.0F), this);
+                DamageReporter.modify_damage(this, source, amount, amount*0.75f, "wearing a helmet"); //CM
                 amount *= 0.75F;
             }
 
@@ -932,6 +943,7 @@
             if (amount > 0.0F && this.canBlockDamageSource(source))
             {
                 this.damageShield(amount);
+                DamageReporter.modify_damage(this, source, amount, 0.0f, "using a shield"); //CM
                 f1 = amount;
                 amount = 0.0F;
 
@@ -955,8 +967,10 @@
             {
                 if (amount <= this.lastDamage)
                 {
+                    DamageReporter.modify_damage(this, source, amount, 0.0f, "Recently hit"); //CM
                     return false;
                 }
+                DamageReporter.modify_damage(this, source, amount, amount - this.lastDamage, "Recently hit"); //CM
 
                 this.damageEntity(source, amount - this.lastDamage);
                 this.lastDamage = amount;
@@ -1407,6 +1421,9 @@
                 int j = 25 - i;
                 float f = damage * (float)j;
                 float f1 = damage;
+
+                DamageReporter.modify_damage(this, source, damage, Math.max(f / 25.0F, 0.0F), "Resistance status effect"); //CM
+
                 damage = Math.max(f / 25.0F, 0.0F);
                 float f2 = f1 - damage;
 
@@ -1433,7 +1450,10 @@
 
                 if (k > 0)
                 {
+                    float previous_damage = damage; // CM store
                     damage = CombatRules.getDamageAfterMagicAbsorb(damage, (float)k);
+                    DamageReporter.modify_damage(this, source, previous_damage, damage,
+                            String.format("enchantments (%.1f total points)", (float)k)); // CM
                 }
 
                 return damage;
@@ -1445,11 +1465,21 @@
     {
         if (!this.isInvulnerableTo(damageSrc))
         {
+            float previous_amount = damageAmount; //CM
             damageAmount = this.applyArmorCalculations(damageSrc, damageAmount);
+
+            DamageReporter.modify_damage(this, damageSrc, previous_amount, damageAmount, //CM
+                    String.format("Armour %.1f, Toughness %.1f", (float)this.getTotalArmorValue(), (float)this.getAttribute(SharedMonsterAttributes.ARMOR_TOUGHNESS).getValue())); //CM
+
+
             damageAmount = this.applyPotionDamageCalculations(damageSrc, damageAmount);
             float f = damageAmount;
             damageAmount = Math.max(damageAmount - this.getAbsorptionAmount(), 0.0F);
             this.setAbsorptionAmount(this.getAbsorptionAmount() - (f - damageAmount));
+
+            DamageReporter.modify_damage(this, damageSrc, damageAmount, f, "Absorbtion"); //CM
+
+
             float f1 = f - damageAmount;
 
             if (f1 > 0.0F && f1 < 3.4028235E37F && damageSrc.getTrueSource() instanceof EntityPlayerMP)
@@ -1460,6 +1490,7 @@
             if (damageAmount != 0.0F)
             {
                 float f2 = this.getHealth();
+                DamageReporter.register_final_damage(this, damageSrc, damageAmount); //CM
                 this.setHealth(f2 - damageAmount);
                 this.getCombatTracker().trackDamage(damageSrc, f2, damageAmount);
                 this.setAbsorptionAmount(this.getAbsorptionAmount() - damageAmount);
@@ -2530,9 +2561,15 @@
                     this.attackEntityFrom(DamageSource.CRAMMING, 6.0F);
                 }
             }
-
-            for (int l = 0; l < list.size(); ++l)
+    
+            // [CM] Tweaked code for max entity collisions
+            int limit = list.size();
+            if (CarpetSettings.getInt("maxEntityCollisions") > 0)
             {
+                limit = Math.min(limit,CarpetSettings.getInt("maxEntityCollisions"));
+            }
+            for (int l = 0; l < limit; ++l)
+            {
                 Entity entity = list.get(l);
                 this.collideWithEntity(entity);
             }
